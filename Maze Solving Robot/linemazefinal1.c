#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int screenHeight = 127;
const int screenWidth = 177;
const int numOfRows = 9; // change these values add one to both and also change the maze sim fun
const int numOfCols = 7; //
int robHeading = 0; // 0=North, 1=East, 2=South, 3=West
typedef struct{
	int nWall; // 0 = door, 1 = wall
	int eWall;
	int sWall;
	int wWall;
}cell;
cell maze[numOfRows][numOfCols];
int arr[300];
int startRow = 0;
int startcol = 0;
int robRow = startRow;
int robCol = startcol;
int targetRow = 0;
int targetCol = 4;

int k = 0;
int y =0;
bool f = true;

void buildOuterBorders();
void gridDraw();
void drawBot();
void turnRight();
void turnLeft();
void goFwd();
void refreshScreen();
void MazeSim();
void mazeSolverRHF();
task main(){
	buildOuterBorders();
	MazeSim();
	mazeSolverRHF();
	sleep(1000);
	eraseDisplay();
	sleep(500);
	displayCenteredTextLine(3,"Now it will solve");
	sleep(1500);
	eraseDisplay();
	displayCenteredTextLine(3,"the maze physically");
	sleep(1500);
	eraseDisplay();
	displayCenteredTextLine(3,"using the shortest path");
	sleep(1500);

	/// THE ALGORITHM BELOW HAS AN ARRAY NAMED "ARR" which is of size 300.
 //// This algorithm will make the array "arr" hold the values (0,1,2,3) that is the equivalent of (N,E,S,W) and also unassigned values 99 that are junk values
 /// the 0,1,2,3 values that the array "arr" will hold are basically the shortest path from the chosen point to the target point


	eraseDisplay();

	for(int i=k;i<300;i++)
	{
		arr[i]=99;
	}
	while( y < 3000){
		for(int g=0;g<k-1;g++)
		{
			if((arr[g]-arr[g+1])==2)
			{
				for(int l = g;l<270;l++)
				{
					arr[l] = arr[l+2];
					arr[l+1] = arr[l+3];
				}
			}
			else if((arr[g]-arr[g+1])== -2)
			{
				for(int l = g;l<270;l++)
				{
					arr[l] = arr[l+2];
					arr[l+1] = arr[l+3];
				}
			}
		}
		y++;
	}

	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	sleep(1000);


	setMotorTarget(rightMotor, 620, 20);
	setMotorTarget(leftMotor, 620, 20);
	waitUntilMotorStop(rightMotor);

       //////
	while(f){
		for(int i=1;i<100;i++)
		{
			resetMotorEncoder(leftMotor);
			resetMotorEncoder(rightMotor);
			if(arr[i]==0)
			{
				if(arr[i-1]==0)
				{
					setMotorTarget(rightMotor, 620, 20);
					setMotorTarget(leftMotor, 620, 20);
					waitUntilMotorStop(rightMotor);
					waitUntilMotorStop(leftMotor);
          // make the robot move around 620 encoder values
				}
				else if(arr[i-1]==1)
				{
					// make the robot turn left and then make it move 620 encoder Vals
					setMotorTarget(rightMotor, 180, 20);
					setMotorTarget(leftMotor, -180, 20);
					waitUntilMotorStop(rightMotor);
					waitUntilMotorStop(leftMotor);
					resetMotorEncoder(leftMotor);
					resetMotorEncoder(rightMotor);
					setMotorTarget(rightMotor, 620, 20);
					setMotorTarget(leftMotor, 620, 20);
					waitUntilMotorStop(rightMotor);
					waitUntilMotorStop(leftMotor);


				}
				else if(arr[i-1]==3)
				{
					// make the robot turn right and then make it move almost 620 encoder values
					setMotorTarget(rightMotor, -180, 20);
					setMotorTarget(leftMotor, 180, 20);
					waitUntilMotorStop(rightMotor);
					waitUntilMotorStop(leftMotor);
					resetMotorEncoder(leftMotor);
					resetMotorEncoder(rightMotor);
					setMotorTarget(rightMotor, 620, 20);
					setMotorTarget(leftMotor, 620, 20);
					waitUntilMotorStop(rightMotor);
					waitUntilMotorStop(leftMotor);
				}

			}
			else if(arr[i]==1)
			{
				if(arr[i-1]==1)
				{
					resetMotorEncoder(leftMotor);
					resetMotorEncoder(rightMotor);
					// make the robot move around 620 encoder values
					setMotorTarget(rightMotor, 620, 20);
					setMotorTarget(leftMotor, 620, 20);
					waitUntilMotorStop(rightMotor);
					waitUntilMotorStop(leftMotor);
				}
				else if(arr[i-1]==0)
				{
                  // make the robot turn right and then make it move almost 620 encoder values
					setMotorTarget(rightMotor, -2*90, 20);
					setMotorTarget(leftMotor, 2*90, 20);
					waitUntilMotorStop(rightMotor);
					waitUntilMotorStop(leftMotor);
					resetMotorEncoder(leftMotor);
					resetMotorEncoder(rightMotor);
					setMotorTarget(rightMotor, 620, 20);
					setMotorTarget(leftMotor, 620, 20);
					waitUntilMotorStop(rightMotor);
					waitUntilMotorStop(leftMotor);

				}
				else if(arr[i-1]==2)
				{
				          // make the robot turn left and then make it move almost 620 encoder values
					setMotorTarget(rightMotor, 2*90, 20);
					setMotorTarget(leftMotor, -180, 20);
					waitUntilMotorStop(rightMotor);
					waitUntilMotorStop(leftMotor);
					resetMotorEncoder(leftMotor);
					resetMotorEncoder(rightMotor);
					setMotorTarget(rightMotor, 620, 20);
					setMotorTarget(leftMotor, 620, 20);
					waitUntilMotorStop(rightMotor);
					waitUntilMotorStop(leftMotor);
				}

			}
			else if(arr[i]==2)
			{
				if(arr[i-1]==2)
				{
					// make the robot move around 620 encoder values
					setMotorTarget(rightMotor, 620, 20);
					setMotorTarget(leftMotor, -620, 20);
					waitUntilMotorStop(rightMotor);
					waitUntilMotorStop(leftMotor);
				}
				else if(arr[i-1]==1)
				{
					// make the robot turn right and then make it move almost 620 encoder values
					setMotorTarget(rightMotor, -180, 20);
					setMotorTarget(leftMotor, 180, 20);
					waitUntilMotorStop(rightMotor);
					waitUntilMotorStop(leftMotor);
					resetMotorEncoder(leftMotor);
					resetMotorEncoder(rightMotor);
					setMotorTarget(rightMotor, 620, 20);
					setMotorTarget(leftMotor, 620, 20);
					waitUntilMotorStop(rightMotor);
					waitUntilMotorStop(leftMotor);
				}
				else if(arr[i-1]==3)
				{
					// make the robot turn left and then make it move almost 620 encoder values
					setMotorTarget(rightMotor, 180, 20);
					setMotorTarget(leftMotor, -180, 20);
					waitUntilMotorStop(rightMotor);
					waitUntilMotorStop(leftMotor);
					resetMotorEncoder(leftMotor);
					resetMotorEncoder(rightMotor);
					setMotorTarget(rightMotor, 620, 20);
					setMotorTarget(leftMotor, 620, 20);
					waitUntilMotorStop(rightMotor);
					waitUntilMotorStop(leftMotor);
				}

			}
			else if(arr[i]==3)
			{
				if(arr[i-1]==3)
				{
					// make the robot move around 620 encoder values
					setMotorTarget(rightMotor, 620, 20);
					setMotorTarget(leftMotor, -620, 20);
					waitUntilMotorStop(rightMotor);
					waitUntilMotorStop(leftMotor);

				}
				else if(arr[i-1]==0)
				{
					// make the robot turn left and then make it move almost 620 encoder values
					setMotorTarget(rightMotor, 2*90, 20);
					setMotorTarget(leftMotor, -180, 20);
					waitUntilMotorStop(rightMotor);
					waitUntilMotorStop(leftMotor);
					resetMotorEncoder(leftMotor);
					resetMotorEncoder(rightMotor);
					setMotorTarget(rightMotor, 620, 20);
					setMotorTarget(leftMotor, 620, 20);
					waitUntilMotorStop(rightMotor);
					waitUntilMotorStop(leftMotor)
				}
				else if(arr[i-1]==2)
				{
					// make the robot turn right and then make it move almost 620 encoder values
					setMotorTarget(rightMotor, -180, 20);
					setMotorTarget(leftMotor, 180, 20);
					waitUntilMotorStop(rightMotor);
					waitUntilMotorStop(leftMotor);
					resetMotorEncoder(leftMotor);
					resetMotorEncoder(rightMotor);
					setMotorTarget(rightMotor, 620, 20);
					setMotorTarget(leftMotor, 620, 20);
					waitUntilMotorStop(rightMotor);
					waitUntilMotorStop(leftMotor);
				}

			}
			else
			{
				break;
			}
		}
		f=false;
	}
while(true)
{
	eraseDisplay();
	sleep(500);
	displayCenteredTextLine(3,"target point reached!!!");
	sleep(500);
}

}
void mazeSolverRHF(){
	turnRight();
	while((robCol != targetCol) || (robRow != targetRow) ){
		switch(robHeading){
		case 0:
			if(maze[robRow][robCol].nWall == 1){
				turnLeft();
				continue;
			}
			break;
		case 1: // facing east
			if(maze[robRow][robCol].eWall == 1){
				turnLeft();
				continue;
			}
			break;
		case 2:
			if(maze[robRow][robCol].sWall == 1){
				turnLeft();
				continue;
			}
			break;
		case 3:
			if(maze[robRow][robCol].wWall == 1){
				turnLeft();
				continue;
			}
			break;
		default: break;
		}
		goFwd();
		turnRight();
	}
	sleep(1000);
	eraseDisplay();
	sleep(500);
	displayCenteredTextLine(3,"Maze solved in memory");
	sleep(1500);
	eraseDisplay();
	displayCenteredTextLine(3,"and the");
	sleep(1500);
	eraseDisplay();
	displayCenteredTextLine(3,"shortest path is found");
	sleep(1500);
}
void MazeSim(){

	maze[0][0].eWall = maze[0][1].eWall = maze[0][1].wWall = maze[0][1].nWall = maze[0][2].wWall = maze[0][2].eWall = 1;
	maze[0][3].nWall = maze[0][3].wWall = maze[0][3].eWall = maze[0][4].eWall = maze[0][4].wWall = 1;
	maze[0][5].eWall = maze[0][5].wWall = maze[0][6].wWall = maze[0][6].eWall = 1;

	maze[1][0].nWall = maze[1][1].sWall = maze[1][1].eWall = maze[1][2].eWall = maze[1][2].wWall = maze[1][3].sWall = 1;
	maze[1][3].wWall = maze[1][4].nWall = maze[1][4].eWall = maze[1][5].eWall = maze[1][5].wWall = maze[1][6].wWall = 1;

	maze[2][0].nWall = maze[2][0].sWall = maze[2][1].nWall = maze[2][4].nWall = maze[2][4].sWall = 1;

	maze[3][0].sWall = maze[3][1].nWall = maze[3][1].sWall = maze[3][1].eWall = maze[3][2].wWall = maze[3][2].eWall = 1;
	maze[3][3].wWall = maze[3][3].nWall = maze[3][4].sWall = maze[3][4].eWall = maze[3][5].eWall = maze[3][5].wWall =1;
	maze[3][6].wWall = 1;

	maze[4][0].nWall = maze[4][0].eWall = maze[4][1].wWall = maze[4][1].sWall = maze[4][3].nWall = maze[4][3].sWall = 1;
	maze[4][3].eWall = maze[4][4].wWall = maze[4][4].eWall = maze[4][5].wWall = maze[4][5].eWall = maze[4][6].wWall = 1;
	maze[4][6].nWall = 1;

	maze[5][0].nWall = maze[5][0].sWall = maze[5][1].nWall = maze[5][1].eWall = maze[5][2].nWall = maze[5][2].eWall = 1;
	maze[5][2].wWall = maze[5][3].nWall = maze[5][3].wWall = maze[5][3].sWall = maze[5][4].eWall = maze[5][5].eWall = 1;
	maze[5][5].wWall = maze[5][6].nWall = maze[5][6].wWall = maze[5][6].sWall = 1;

	maze[6][0].nWall = maze[6][0].sWall = maze[6][1].nWall = maze[6][1].sWall = maze[6][2].nWall = maze[6][2].sWall =1;
	maze[6][3].nWall = maze[6][3].sWall = maze[6][4].nWall = maze[6][4].eWall = maze[6][5].eWall = maze[6][5].wWall =1;
	maze[6][6].sWall = maze[6][6].wWall =1;

	maze[7][0].nWall = maze[7][0].sWall = maze[7][1].nWall = maze[7][1].sWall = maze[7][2].sWall = maze[7][3].nWall =1;
	maze[7][3].sWall = maze[7][4].nWall = maze[7][4].sWall = maze[7][6].nWall =1;

	maze[8][0].sWall = maze[8][1].sWall = maze[8][1].eWall = maze[8][2].eWall = maze[8][2].wWall = maze[8][3].wWall =1;
	maze[8][3].sWall = maze[8][4].sWall = maze[8][4].eWall = maze[8][5].wWall = maze[8][6].sWall =1;
}
void refreshScreen(){
	eraseDisplay();
	gridDraw();
	drawBot();
}
void goFwd(){
	refreshScreen();
	wait1Msec(250); // waste some time to simulate motion
	if (robHeading==0) { // Going Fwd North
		robRow++;

		arr[k] = 0;
		k= k+1;
	}
	else if (robHeading==1) { // Going Fwd East
		robCol++;

		arr[k] = 1;
		k= k+1;
	}
	else if (robHeading==2) { // Going Fwd South
		robRow--;

		arr[k] = 2;
		k= k+1;
	}
	else if (robHeading==3) { // Going Fwd West
		robCol--;

		arr[k] = 3;
		k= k+1;
	}
	else {
		robRow = 99;
		robCol = 99;
	}
}
void turnRight(){
	refreshScreen();
	if (robHeading < 3){
		robHeading++;
	}
	else robHeading=0;
}
void turnLeft(){
	refreshScreen();
	if (robHeading > 0){
		robHeading--;
	}
	else robHeading=3;
}
void buildOuterBorders(){
	for(int col=0; col<numOfCols; col++){
		maze[0][col].sWall = 1;
		maze[numOfRows-1][col].nWall = 1;
	}
	for(int row=0; row<numOfRows; row++){
		maze[row][0].wWall = 1;
		maze[row][numOfCols-1].eWall = 1;
	}
}
//=====================================================================
void gridDraw(){
	int XStart=0;
	int YStart=0;
	int XEnd =0;
	int YEnd =0;
	for(int i=0;i<numOfRows;i++){
		for(int j=0;j<numOfCols;j++){
			if(maze[i][j].nWall==1){
				XStart= j *screenWidth/numOfCols;
				YStart=(i+1)*screenHeight/numOfRows;
				XEnd =(j+1)*screenWidth/numOfCols;
				YEnd =(i+1)*screenHeight/numOfRows;
				drawLine(XStart,YStart,XEnd,YEnd);
			}
			if (maze[i][j].eWall==1){
				XStart=(j+1)*screenWidth/numOfCols;
				YStart=(i)*screenHeight/numOfRows;
				XEnd =(j+1)*screenWidth/numOfCols;
				YEnd =(i+1)*screenHeight/numOfRows;
				drawLine(XStart,YStart,XEnd,YEnd);
			}
			if (maze[i][j].wWall==1){
				XStart= j *screenWidth/numOfCols;
				YStart=(i)*screenHeight/numOfRows;
				XEnd =(j)*screenWidth/numOfCols;
				YEnd =(i+1)*screenHeight/numOfRows;
				drawLine(XStart,YStart,XEnd,YEnd);
			}
			if(maze[i][j].sWall==1){
				XStart= j *screenWidth/numOfCols;
				YStart=(i)*screenHeight/numOfRows;
				XEnd =(j+1)*screenWidth/numOfCols;
				YEnd =(i)*screenHeight/numOfRows;
				drawLine(XStart,YStart,XEnd,YEnd);
			}
		}
	}
}
//=====================================================================
void drawBot(){
	int RobotXpixelPos=0;
	int RobotYpixelPos=0;
	if(robCol==0){
		RobotXpixelPos=screenWidth/14;
	}
	else{
		RobotXpixelPos=(2*robCol+1)*screenWidth/14;
	}
	if(robRow==0){
		RobotYpixelPos=screenHeight/18;
	}
	else{
		RobotYpixelPos=(2*robRow+1)*screenHeight/18;
	}
	switch(robHeading){
	case 0: displayStringAt(RobotXpixelPos,RobotYpixelPos,"^");
		break; // Facing North
	case 1: displayStringAt(RobotXpixelPos,RobotYpixelPos,">");
		break; // Facing East
	case 2: displayStringAt(RobotXpixelPos,RobotYpixelPos,"V");
		break; // Facing South
	case 3: displayStringAt(RobotXpixelPos,RobotYpixelPos,"<");
		break; // Facing West
	default: break;
	}
}
